/*
 * generated by Xtext 2.13.0
 */
package org.xtext.tdl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import org.xtext.tdl.tdl.Robot
import org.xtext.tdl.tdl.RosNode
import org.xtext.tdl.tdl.CompositeTask
import helperMethods.HelperMethods
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TdlGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
  
  
  		// For Each Robot
		for (robot : resource.allContents.toIterable.filter(Robot)) {
			
			// For Each of the Robots Node
			for (rosNode : robot.getRosNodes()) {
				
				// If Custom Node Generate File For It
				if (rosNode.nodeName === null) {
					val generated_string = generate_ros_node(rosNode).toString
					val generated_string_without_tabs = HelperMethods.removeLeadingTabs(generated_string)
					fsa.generateFile("/" + robot.name + "/" + robot.name + "_" + rosNode.name + ".py", generate_robot_files_from_string(generated_string_without_tabs)) 
				}
				
				// If ROS Provided Node Generate Yaml Parameter File
				if (rosNode.nodeName !== null && rosNode.parameterList !== null) {
					val generated_string_2 = generate_yaml_file(rosNode).toString
					val generated_string_2_without_tabs = HelperMethods.format_yaml_file(generated_string_2)
					fsa.generateFile("/" + robot.name + "/" + rosNode.nodeName + ".yaml", generate_robot_files_from_string(generated_string_2_without_tabs)) 
				}
			}
			
			// Generate ROS Launch File
	        fsa.generateFile("/" + robot.name + "/" + robot.name + ".launch", generate_launch_file(robot))
	        
	        // Generate Startup File 
	        fsa.generateFile("/" + robot.name + "/" + robot.name + "_startup.py", generate_startup_file(robot))
			
			// Generate Task Allocation Module
			val generated_string = generate_task_allocation_module(robot).toString
			val generated_string_without_tabs = HelperMethods.removeLeadingTabs(generated_string)
			fsa.generateFile("/" + robot.name + "/" + robot.name + "_task_allocation_module.py", generate_robot_files_from_string(generated_string_without_tabs))  
        }
        
        // Needed To Support the Definition of Tasks in a Sepperate File from Robots
        var task_nr = 0
		for (task : resource.allContents.toIterable.filter(CompositeTask)) {
			task_nr++
        }
        
        // Generate Index File
        if (task_nr > 0) {
			fsa.generateFile("/index.html", generate_web_interface(resource))
        }
	}
	
	
	def generate_task_allocation_module(Robot robot)
	
	'''
	
	«IF robot.initializationModule !== null»
	«"\t\t"»«robot.initializationModule.codeBlock»
	«ENDIF»
	
			«FOR action : robot.simpleActions»
			«IF action.positional === null»
			def «action.name»(«IF action.parameters !== null»«FOR parameter : action.parameters SEPARATOR ','»«parameter.name»«ENDFOR»«ENDIF»):
			«ENDIF»
			«IF action.positional !== null» 
			def «action.name»(lat,lng):
			«ENDIF»
			«"\t\t"»«action.codeBlock»
			«ENDFOR»
			
			«FOR line : HelperMethods.get_codeLines_from_file("Task Allocation Module Part 1", "/modules/task_allocation_module.py")»
			«line»
			«ENDFOR»
			
			    robot_sensor_data_topic.publish(json.dumps(my_sensor_data))
			
			
			«FOR line : HelperMethods.get_codeLines_from_file("Task Allocation Module Part 2", "/modules/task_allocation_module.py")»
			«line»
			«ENDFOR»
			
			my_sensor_data = {
					"robot_id": "«robot.name»",
			        "topics": [
			        «IF robot.publishedData !== null»
			        «FOR topic : robot.publishedData.topics»
			          {
			            "topic_name" : "«topic.name»",
			            "topic_value" : "0"
			          },
			          «ENDFOR»
			          «ENDIF»
			        ]
			    }
			
			«IF robot.publishedData !== null»
			«FOR topic : robot.publishedData.topics»
			
			def «topic.name»_callback(sensor_value_json):
				sensor_value = json.loads(sensor_value_json.data)
				for topic in my_sensor_data["topics"]:
					if topic.get("topic_name") == "«topic.name»":
						topic["topic_value"] = sensor_value
				
			rospy.Subscriber("«robot.name»/«topic.topic»", String, «topic.name»_callback)
			
			«ENDFOR»
			«ENDIF»
			
			my_actions_table = {
			        "actions": [
			        «FOR action : robot.simpleActions»
			          {
			            "action_name" : "«action.name»",
			            "action_status" : "not_doing"
			          },
			          «ENDFOR»
			        ]
			    }
			    
			robot_status_table = {
			        "robot_id": "«robot.name»",
			        "ip_address": "0",
			        "recovering": "0",
			        "recovered_from_task_with_id": "0"
			    }
			    
			    
			robot_sensor_data_topic = rospy.Publisher('sensor_data', String, queue_size=10)
			
			«FOR line : HelperMethods.get_codeLines_from_file("Task Allocation Module Part 3", "/modules/task_allocation_module.py")»
			«line»
			«ENDFOR»
			
							    
			«FOR line : HelperMethods.get_codeLines_from_file("Task Allocation Module Part 4", "/modules/task_allocation_module.py")»
			«line»
			«ENDFOR»
	
	'''
	
	
	
	def generate_robot_files_from_string(ArrayList<String> lines)
	
	'''
	«FOR line : lines»
	«line»
	«ENDFOR»
	'''
	
	
	
	def generate_ros_node(RosNode rosNode)
	
	'''
	«"\t\t"»«rosNode.codeBlock»
	
	'''
	
	
	
	def generate_launch_file(Robot robot)
	
	'''
	<?xml version="1.0" encoding="UTF-8"?>
	
	<launch>
	    
	    <group ns="«robot.name»">
			
			«FOR rosNode : robot.rosNodes»
				«IF rosNode.nodeName === null»
				<node pkg="multi-robot-simulation" type="«robot.name»_«rosNode.name».py" name="«robot.name»_«rosNode.name»" output="screen">
					<remap from="/tf" to="/«robot.name»/tf" />
				</node>
				«ENDIF»
				«IF rosNode.nodeName !== null»
				<node pkg="«rosNode.name»" type="«rosNode.nodeType»" name="«rosNode.nodeName»" output="screen" «IF rosNode.nodeArgs !== null» args="«rosNode.nodeArgs»"«ENDIF» >
					<remap from="/tf" to="/«robot.name»/tf" />
					«IF rosNode.parameterList !== null»
					<rosparam file="$(find multi-robot-simulation)/src/«robot.name»/«rosNode.nodeName».yaml" command="load" />
					«ENDIF»
				</node> 
				«ENDIF»
			«ENDFOR»
		
	    </group>
	    
	    <node pkg="multi-robot-simulation" type="«robot.name»_task_allocation_module.py" name="«robot.name»_task_allocation_module" output="screen">
		</node>
	
	
	
	</launch>

	
	'''
	
	
	def generate_startup_file(Robot robot)
	
	'''
	SERVER_IP_ADDRESS = "localhost"
	import time
	import subprocess
	robot_status_table = {
	        "robot_id": "«robot.name»",
	        "ip_address": "0",
	    }
				    
				    
	def get_ros_master_ip_address_from_server():
	    server_response = None
	    ws = None
	    while server_response == None:
	        try:
	            import json
	            import sys, ast, math
	            from websocket import create_connection
	            ws = create_connection("ws://" + SERVER_IP_ADDRESS + ":9001/")
	            ws.send(json.dumps(["0", robot_status_table.get("robot_id"), robot_status_table.get("robot_ip_address")]))
	            server_response = ast.literal_eval(ws.recv())
	        except:
	          print('\033[94m' + robot_status_table.get("robot_id") + ": Trying to Connect to Server" + '\033[0m')
	          time.sleep(2)
	        finally:
	          if ws != None:
	              ws.close()
	    return server_response
				    
				    
	if __name__ == '__main__':
	
	    import socket    
	    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	    s.connect(("8.8.8.8", 80))
	    robot_status_table["robot_ip_address"] = s.getsockname()[0]
	    s.close() 
	
	    message = get_ros_master_ip_address_from_server()
	
	    subprocess.Popen("export ROS_MASTER_URI=http://" + message[1] + ":11311; export ROS_IP=" + robot_status_table.get("robot_ip_address") + "; export ROS_HOSTNAME=" + robot_status_table.get("robot_ip_address") + "; roslaunch multi-robot-simulation «robot.name».launch", shell=True).wait()
	    	      
	'''
	
	
	
	def generate_yaml_file(RosNode rosNode)
	
	'''
	
	«"\t\t"»«rosNode.parameterList.codeBlock»
	
	
	'''
	
	
	
	def generate_web_interface(Resource resource)
	'''
	
	«FOR line : HelperMethods.get_codeLines_from_file("Index Part 1", "/modules/index.html")»
	«line»
	«ENDFOR»
	
	«FOR compositeTask : resource.allContents.toIterable.filter(CompositeTask)»
				<input id="«compositeTask.name»" class="button_task" type="button" value="«compositeTask.name»" onclick="setTask('«compositeTask.name»');" />
	«ENDFOR»
	
	<script>
	task_definitions = {
							"composite_tasks": [
							«FOR compositeTask : resource.allContents.toIterable.filter(CompositeTask)»
							{
								"composite_task_name" : "«compositeTask.name»",
								"tasks": [
								«FOR task : compositeTask.tasks»
								{
									"task_name" : "«task.name»",
									"actions" : [
									«FOR simpleAction : task.simpleActions»
									{
										"action_name" : "«simpleAction.name»",
										"action_status" : "not_doing",
										«IF simpleAction.positional !== null»
										"positioning_action" : "True",
										«ENDIF»
										«IF simpleAction.positional === null»
										"positioning_action" : "False",
										«ENDIF»
										«IF simpleAction.id !== null»
										"action_id" : "«simpleAction.id»",
										«ENDIF»
										«IF simpleAction.sync !== 0»
										"sync_number" : "«simpleAction.sync»",
										«ENDIF»			
										«IF simpleAction.after !== null»
										"after_action" : "«simpleAction.after»",
										«ENDIF»
										"arguments": [«FOR argument : simpleAction.arguments SEPARATOR ','»"«argument.name»"«ENDFOR»],
									},
									«ENDFOR»
									]
								},
								«ENDFOR» 
								]
							},
							«ENDFOR»
							]
						}
	</script>
	
	«FOR line : HelperMethods.get_codeLines_from_file("Index Part 2", "/modules/index.html")»
	«line»
	«ENDFOR»
	
	'''

	
}






