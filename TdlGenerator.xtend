/*
 * generated by Xtext 2.13.0
 */
package org.xtext.tdl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import org.xtext.tdl.tdl.Robot
import org.xtext.tdl.tdl.ProcessingNode
import helperMethods.HelperMethods
import java.util.ArrayList
import org.xtext.tdl.tdl.CompositeTask

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TdlGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
  
  
  		// For Each Robot
		for (robot : resource.allContents.toIterable.filter(Robot)) {
			
			// For Each of the Robots Node
			for (processingNode : robot.getProcessingNodes()) {
				
				// If Custom Node Generate File For It
				if (processingNode.nodeName === null) {
					val generated_string = generate_processing_node(processingNode).toString
					val generated_string_without_tabs = HelperMethods.removeLeadingTabs(generated_string)
					fsa.generateFile("/" + robot.name + "/" + robot.name + "_" + processingNode.name + ".py", generate_robot_files_from_string(generated_string_without_tabs)) 
				}
				
				// If ROS Provided Node Generate Yaml Parameter File
				if (processingNode.nodeName !== null && processingNode.codeBlock !== null) {
					val generated_string_2 = generate_yaml_file(processingNode).toString
					val generated_string_2_without_tabs = HelperMethods.format_yaml_file(generated_string_2)
					fsa.generateFile("/" + robot.name + "/" + processingNode.nodeName + ".yaml", generate_robot_files_from_string(generated_string_2_without_tabs)) 
				}
			}
			
			// Generate ROS Launch File
	        fsa.generateFile("/" + robot.name + "/" + robot.name + ".launch", generate_launch_file(robot))
			
			// Generate Task Allocation Module
			val generated_string = generate_task_allocation_module(robot).toString
			val generated_string_without_tabs = HelperMethods.removeLeadingTabs(generated_string)
			fsa.generateFile("/" + robot.name + "/" + robot.name + "_task_allocation_module.py", generate_robot_files_from_string(generated_string_without_tabs))  
        }
        
        // Needed To Support the Definition of Tasks in a Sepperate File from Robots
        var task_nr = 0
		for (task : resource.allContents.toIterable.filter(CompositeTask)) {
			task_nr++
        }
        
        // Generate Backend and Index File
        if (task_nr > 0) {
        	fsa.generateFile("/backend.py", generate_python_backend(resource))
			fsa.generateFile("/index.html", generate_web_interface(resource))
        }
	}
	
	
	def generate_task_allocation_module(Robot robot)
	
	'''
	
	«IF robot.setupMethod != null»
	«"\t\t"»«robot.setupMethod.codeBlock»
	«ENDIF»
	
			«FOR action : robot.simpleActions»
			«IF action.position !== null»
			def «action.name»(lat,lng):
			«ENDIF»
			«IF action.position === null»
			def «action.name»():
			«ENDIF»
			«"\t\t"»«action.codeBlock»
			«ENDFOR»
			
			«FOR line : HelperMethods.get_codeLines_from_file("Task Allocation Module Part 1", "/runTimeEngine/task_allocation_module.py")»
			«line»
			«ENDFOR»
			
			    robot_sensor_data_topic.publish(json.dumps(my_sensor_data))
			
			
			«FOR line : HelperMethods.get_codeLines_from_file("Task Allocation Module Part 2", "/runTimeEngine/task_allocation_module.py")»
			«line»
			«ENDFOR»
			
			my_sensor_data = {
					"robot_id": "«robot.name»",
			        "topics": [
			        «IF robot.publishedData !== null»
			        «FOR sensorData : robot.publishedData.sensorData»
			          {
			            "topic_name" : "«sensorData.name»",
			            "topic_value" : "0"
			          },
			          «ENDFOR»
			          «ENDIF»
			        ]
			    }
			
			«IF robot.publishedData !== null»
			«FOR sensorData : robot.publishedData.sensorData»
			
			def «sensorData.name»_callback(sensor_value_json):
				sensor_value = json.loads(sensor_value_json.data)
				for topic in my_sensor_data["topics"]:
					if topic.get("topic_name") == "«sensorData.name»":
						topic["topic_value"] = sensor_value
				
			rospy.Subscriber("«robot.name»/«sensorData.topic»", String, «sensorData.name»_callback)
			
			«ENDFOR»
			«ENDIF»
			
			my_actions_table = {
			        "actions": [
			        «FOR action : robot.simpleActions»
			          {
			            "action_name" : "«action.name»",
			            "action_status" : "not_doing"
			          },
			          «ENDFOR»
			        ]
			    }
			    
			robot_status_table = {
			        "robot_id": "«robot.name»",
			        "ip_address": "0",
			        "recovering": "0",
			        "recovered_from_task_with_id": "0"
			    }
			    
			    
			robot_sensor_data_topic = rospy.Publisher('sensor_data', String, queue_size=10)
			
			«FOR line : HelperMethods.get_codeLines_from_file("Task Allocation Module Part 3", "/runTimeEngine/task_allocation_module.py")»
			«line»
			«ENDFOR»
	
	'''
	
	
	
	def generate_robot_files_from_string(ArrayList<String> lines)
	
	'''
	«FOR line : lines»
	«line»
	«ENDFOR»
	'''
	
	
	
	def generate_processing_node(ProcessingNode processingNode)
	
	'''
	«"\t\t"»«processingNode.codeBlock»
	
	'''
	
	
	
	def generate_launch_file(Robot robot)
	
	'''
	<?xml version="1.0" encoding="UTF-8"?>
	
	<launch>
	    
	    <group ns="«robot.name»">
			
			«FOR processingNode : robot.processingNodes»
				«IF processingNode.nodeName === null»
				<node pkg="multi-robot-simulation" type="«robot.name»_«processingNode.name».py" name="«robot.name»_«processingNode.name»" output="screen">
					<remap from="/tf" to="/«robot.name»/tf" />
				</node>
				«ENDIF»
				«IF processingNode.nodeName !== null»
				<node pkg="«processingNode.name»" type="«processingNode.nodeType»" name="«processingNode.nodeName»" output="screen" «IF processingNode.nodeArgs !== null» args="«processingNode.nodeArgs»"«ENDIF» >
					<remap from="/tf" to="/«robot.name»/tf" />
					«IF processingNode.codeBlock !== null»
					<rosparam file="$(find multi-robot-simulation)/src/«robot.name»/«processingNode.nodeName».yaml" command="load" />
					«ENDIF»
				</node> 
				«ENDIF»
			«ENDFOR»
		
	    </group>
	    
	    <node pkg="multi-robot-simulation" type="«robot.name»_task_allocation_module.py" name="«robot.name»_task_allocation_module" output="screen">
		</node>
	
	
	
	</launch>

	
	'''
	
	
	def generate_yaml_file(ProcessingNode processingNode)
	
	'''
	
	«"\t\t"»«processingNode.codeBlock»
	
	
	'''
	
	
	
	
	def generate_python_backend(Resource resource) 
	
	'''
	
	«FOR line : HelperMethods.get_codeLines_from_file("Backend Part 1", "/runTimeEngine/backend.py")»
	«line»
	«ENDFOR»
	
	task_definitions = {
		"composite_tasks": [
		«FOR compositeTask : resource.allContents.toIterable.filter(CompositeTask)»
		{
			"composite_task_name" : "«compositeTask.name»",
			"tasks": [
			«FOR task : compositeTask.tasks»
			{
				"task_name" : "«task.name»",
				"actions" : [
				«FOR simpleAction : task.simpleActions»
				{
					"action_name" : "«simpleAction.name»",
					"action_status" : "not_doing",
					«IF simpleAction.position !== null»
					"positioning_action" : "True",
					«ENDIF»
					«IF simpleAction.position === null»
					"positioning_action" : "False",
					«ENDIF»
					«IF simpleAction.id !== 0»
					"action_id" : "«simpleAction.id»"
					«ENDIF»			
					«IF simpleAction.after !== 0»
					"after_action" : "«simpleAction.after»"
					«ENDIF»
				},
				«ENDFOR»
				]
			},
			«ENDFOR»
			]
		},
		«ENDFOR»
		]
	}
				    
	«FOR line : HelperMethods.get_codeLines_from_file("Backend Part 2", "/runTimeEngine/backend.py")»
	«line»
	«ENDFOR»
	
	'''
	
	
	
	def generate_web_interface(Resource resource)
	'''
	
	«FOR line : HelperMethods.get_codeLines_from_file("Index Part 1", "/runTimeEngine/index.html")»
	«line»
	«ENDFOR»
	
	«FOR compositeTask : resource.allContents.toIterable.filter(CompositeTask)»
				<input id="«compositeTask.name»" class="button_task" type="button" value="«compositeTask.name»" onclick="setTask('«compositeTask.name»');" />
	«ENDFOR»
	
	«FOR line : HelperMethods.get_codeLines_from_file("Index Part 2", "/runTimeEngine/index.html")»
	«line»
	«ENDFOR»
	
	'''

	
}






