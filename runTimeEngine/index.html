<!--

	@start Index Part 1

-->

<!DOCTYPE html>

<html>
	<head>

		<title>Console</title>

		<meta charset="utf-8" />

		<style>
			html{
			    min-height:100%;/* make sure it is at least as tall as the viewport */
			    position:relative;
			}
			body{
			    height:100%; /* force the BODY element to match the height of the HTML element */
			}
			#mapid{
			    position:absolute;
			    top:0;
			    bottom:0;
			    left:0;
			    right:0;
			    overflow:hidden;
			    z-index:0;
			}
			.error_message {
			        position: absolute;
			        text-align: center;
			        top: 30%;
			        left: 30%;
			        width: 40%;
			        font-size: 40px;
			        color: red;
			    }
			.buttonBox {
			        position:absolute;
			        top:20px;
			        right:20px;
			        height: 300px;
			        width: 150px;
				z-index: 1001;
				opacity: 0.8
			    }
			.button_task {
			        height: 40px; 
			        width: 100%; 
			        font-size: 18px; 
			    }
        </style>
        
		
		<!-- include stylesheet for leaflet -->
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css"
			integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
			crossorigin=""/>
			
		<!-- Make sure you put this AFTER Leaflet's CSS -->
		<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"
			integrity="sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA=="
			crossorigin=""></script>
		

    </head>

	<body height = 100% width = 100%>
            <div id="error_message" class="error_message"></div>

		<div class="buttonBox">
		
<!--

	@end Index Part 1

-->

<!--

	@start Index Part 2

-->
		
		</div>
		
		
		<div id="mapid"></div>

		<script>

			//60.396346, 5.321288 # Bergen
			//37.619374, -122.376637 # San Francisco
			var mymap = L.map('mapid').setView([0, 0], 17);
			// this access token is the one used in the examples of the tutorial
			// in theory one should get an own one, but it works for now and that's all I want for testing
			L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
				maxZoom: 20,
				attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
					'<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
					'Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
				id: 'mapbox.streets'
			}).addTo(mymap);


			function onMapClick(e) {
				var newpos = e.latlng;
				
				console.log("Task:" + task)
				if(task === "search") { 
					console.log(newpos)
					doSearchTask(newpos)
				}
				else if(task === "line") {
					doLineTask(newpos)
				}
				else if(task === "pickup") {
					doPickupTask(newpos)
				}
				else if(task === "obstacle") {
					doObstacle(newpos)
				}
				
			}
			mymap.on('click', e => {
				console.log(e)
				var startposmarker = L.marker([0,0]);
				startposmarker.setLatLng(e.latlng);
				startposmarker.addTo(mymap);
				positionClicked(e.latlng)
			});

			var map_markers = new Map();
		
		
			var ws;
			function init() {
				// Connect to Web Socket
				ws = new WebSocket("ws://localhost:9001/");
	
				// Set event handlers.
				ws.onopen = function() {
					console.log("Server Online");
				};
                
                // Data from backend
				ws.onmessage = function(e) {
					var data = JSON.parse(e.data);
				}.bind(this);
				
				ws.onclose = function() {
					console.log("Server Closed");
					alert("server disconnected - you may as well close this tab");
				};
	
				ws.onerror = function(e) {
					console.log("Server Error");
					console.log(e);
					alert(e);
				};
			}
			
			function taskClicked(task_name) {
				ws.send(JSON.stringify([0, task_name]));
			}
			function positionClicked(pos) {
				ws.send(JSON.stringify([1, pos]));
			}


			async function display_error_message(message) {
				document.getElementById('error_message').innerHTML = message;
				await sleep(3)
				document.getElementById('error_message').innerHTML = "";
			}

			function sleep(s) {
				return new Promise(resolve => setTimeout(resolve, s*1000));
			}

			init();
			
		</script>
				
	</body>

</html>

<!--

	@end Index Part 2

-->